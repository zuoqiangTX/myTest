/*并发集合*/
  一些集合类不能直接用于并发应用，因为他们没有对本身数据的并发访问进行控制。一些并发任务采用了不合适的数据结构，将会遇到不一致
  的情况。
  因此在并发程序中使用集合数据时候，必须谨慎地选择相应的实现方式。java提供了两种适用于并发应用的集合。
  1）阻塞式集合
  当集合已满或为空的时候，被调用的添加和移除方法不能立即执行，调用这个方法的线程将被阻塞，直到该方法可以被成功执行。
  2）非阻塞式集合
    当集合已满或为空的时候，被调用的添加和移除方法不能立即执行，则返回null或者抛出异常，但是调用这个方法的线程不会被阻塞。


一、使用非阻塞线程安全列表   ConcurrentLinkedDeque
    如果操作不能立即执行，返回null或者抛出异常，不会阻塞。
    1）add 方法添加到列表尾部 pollFirst返回并移除列表的第一个元素 pollLast返回并移除列表的最后一个元素
    2）需要注意到 size方法可能不是真实的，因为数据在不断变化，当没有线程修改列表的时候，才能保证返回的结果准确。
    特别注意：peek、get取出元素，但是不会将元素移除


二、使用阻塞线程安全列表     LinkedBlockingDeque
    如果操作不能立即执行，调用操作的线程会阻塞，直到可以执行的时候才执行。
    1)put将字符串插入列表，如果列表已满（列表生成时固定了数量），则调用这个方法的线程将要被阻塞到列表有可用的空间。
    2)take从列表中取字符串，如果列表为空，调用方法的线程将被阻塞直到列表不为空。
    调用线程可能被阻塞，如果被阻塞时候被中断，将抛出InteruptedException 异常，必须捕获和处理这个异常。



三、使用按优先级排列的阻塞式线程安全列表   PriorityBlockingQueue
    1）所有添加进 PriorityBlockingQueue 的元素必须实现Comparable接口，实现其中的compareTo方法，当前对象小于传入对象，返回负数。大于当前对象，返回大于
       0的值。
       PriorityBlockingQueue根据compareTo决定存放元素的位置，元素越大越靠后。
    2）当它的方法被调用并且不能被立即执行的时候，调用该方法的线程将被阻塞到方法执行成功。
    3) 注意带有Blocking的才是阻塞的！！！ add 和poll方法常用

四、使用带有延迟元素的线程安全列表 DelayQueue
    1)存放到其中的元素必须 继承Delayed接口，它使存放在DelayQueue中的对象有了激活日期
    2)调用的poll方法是非阻塞的，取不到元素会直接 取到null。

五、使用线程安全可遍历映射 ConcrrentSkipListMap 貌似不是很重要
   它是一个非阻塞列表，内部使用了一个Skip List来存放数据，效率和二叉树相近，比有序列表在增删查询数据 更省时间。



六、并发生成随机数 ThreadLocalRandom
     1）线程本地变量，每一个生成随机数的线程都有一个不同的生成器，但是都在同一类中被管理，
       相比较使用共享的Random对象为所有线程生成随机数字，具有更好的性能。


七、使用原子变量   AtomicLong
     使用CAS(Compare and Set)操作，保证多个线程同一时间操作一个原子变量不会产生不一致的情况，性能优于同步机制保护的变量。
     CAS操作：操作先获取变量值，然后本地改变变量的值，然后试图用改变的值去替换之前的值，如果之前的值没有被其他线程改变，就可以执行
     操作，否则， 方法将再次执行这个操作。

八、使用原子数组   AtomicIntegerArray
   实现并发操作的时候，不可避免会产生多线程共享一个或者多个对象的现象，为了避免数据不一致，采用同步机制（锁）来保护共享变量的访问，但是这些
   同步机制会有以下问题：
   1）死锁  2）只有一个线程访问的时候，依然需要获取和释放锁。
   为了改善上面的情况，采用了 比较和交换操作（CAS）。
   原子变量提供了 compareAndSet()方法。
